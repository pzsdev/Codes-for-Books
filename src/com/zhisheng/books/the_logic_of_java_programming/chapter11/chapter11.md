### 第 11 章 堆与优先级队列

堆作为一种数据结构可以非常高效方便地解决很多问题，比如：

1）优先级队列，我们之前介绍的队列实现类LinkedList是按添加顺序排列的，
但现实中，经常需要按优先级来，每次都应该处理当前队列中优先级最高的，
高优先级的即使来得晚，也应该被优先处理。

2）求前K个最大的元素，元素个数不确定，数据量可能很大，甚至源源不断到来，
但需要知道到目前为止的最大的前K个元素。这个问题的变体有：求前K个最小的元素，
求第K个最大的元素，求第K个最小的元素。

3）求中值元素，中值不是平均值，而是排序后中间那个元素的值，同样，
数据量可能很大，甚至源源不断到来。堆还可以实现排序，称之为堆排序，
不过有比它更好的排序算法，所以，我们就不介绍其在排序中的应用了。

Java容器中有一个类PriorityQueue，表示优先级队列，它实现了堆。

#### 11.1 堆的概念与算法

##### 11.1.1 基本概念

**完全二叉树** 定义：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

**满二叉树**：一颗二叉树，除了最后一层外，每个节点都有有两个孩子，而最后一层都是叶子节点，都没有孩子。   
也就是说：如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。   
也就是说：如果一棵二叉树只有度为0的节点和度为2的节点，并且度为0的节点在同一层上，则这棵二叉树为满二叉树。

满二叉树国内定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的深度为K，且结点总数是(2^k) -1 ，则它就是满二叉树。

满二叉树一定是完全二叉树。

完全二叉树不要求最后一层是满的，但如果不满，则要求所有节点必须集中在最左边，从左到右是连续的，中间不能有空的。

**节点的度**：一个节点拥有子树的数目称为节点的度。

**叶子节点**：也称为终端节点，没有子树的节点或者度为零的节点。

**分支节点**：也称为非终端节点，度不为零的节点称为非终端节点。

完全二叉树有一个重要的特点：给定任意一个节点，可以根据其编号直接快速计算出其父节点和孩子节点编号。

这个特点为什么重要呢？它使得逻辑概念上的二叉树可以方便地存储到数组中，
数组中的元素索引就对应节点的编号，树中的父子关系通过其索引关系隐含维持，不需要单独保持。

使用数组存储的优点是节省空间，而且访问效率高。`堆`逻辑概念上是一棵完全二叉树，
而物理存储上使用数组，还有一定的顺序要求。

与排序二叉树不同，在堆中，可以有重复元素，元素间不是完全有序的，但对于父子节点之间，
有一定的顺序要求。

根据顺序分为两种堆：一种是最大堆，另一种是最小堆。

最大堆是指每个节点都不大于其父节点。这样，对每个父节点，一定不小于其所有孩子节点，
而根节点就是所有节点中最大的，对每个子树，子树的根也是子树所有节点中最大的。
最小堆与最大堆正好相反，每个节点都不小于其父节点。

逻辑概念上，堆是完全二叉树，父子节点间有特定顺序，分为最大堆和最小堆，最大堆根是最大的，
最小堆根是最小的，堆使用数组进行物理存储。

##### 11.1.2 堆的算法

下面，我们介绍如何在堆上进行数据的基本操作。最大堆和最小堆的算法是类似的，我们以 **最小堆** 来说明。

**1.添加元素**

如果堆为空，则直接添加一个根就行了。我们假定已经有一个堆，要在其中添加元素，基本步骤为：   
1）添加元素到最后位置。   
2）与父节点比较，如果大于等于父节点则满足堆的性质，结束，否则与父节点进行交换，
然后再与父节点比较和交换，直到父节点为空或者大于等于父节点。

添加一个元素，需要比较和交换的次数最多为树的高度，即log2(N), N为节点数。
这种自底向上比较、交换，使得树重新满足堆的性质的过程，我们称为`向上调整（siftup）`。

**2. 从头部删除元素**

在队列中，一般是从头部删除元素，Java中用堆实现优先级队列。

下面介绍如何在堆中删除头部，其基本步骤为：   
1）用最后一个元素替换头部元素，并删掉最后一个元素；   
2）将新的头部与两个孩子节点中较小的比较，如果不大于该孩子节点，则满足堆的性质，结束，
否则与较小的孩子节点进行交换，交换后，再与较小的孩子节点比较和交换，一直到没有孩子节点，
或者不大于两个孩子节点。这个过程称为`向下调整（siftdown）`。

**3. 从中间删除元素**

那如果需要从中间删除某个节点呢？与从头部删除一样，都是先用最后一个元素替换待删元素。
不过替换后，有两种情况：如果该元素大于某孩子节点，则需向下调整（sift-down）；如果小于父节点，则需向上调整（siftup）。

**4. 构建初始堆**


**5. 查找和遍历**

**6. 算法小结**

以上就是堆操作的主要算法，小结如下。   
1）在添加和删除元素时，有两个关键的过程以保持堆的性质，一个是向上调整（siftup），
另一个是向下调整（siftdown），它们的效率都为O(log2(N))。
由无序数组构建堆的过程heapify是一个自底向上循环的过程，效率为O(N)。   
2）查找和遍历就是对数组的查找和遍历，效率为O(N)。

##### 11.1.3 小结

本节介绍了堆这一数据结构的基本概念和算法。
堆是一种比较神奇的数据结构，概念上是树，存储为数组，父子有特殊顺序，
根是最大值/最小值，构建/添加/删除效率都很高，可以高效解决很多问题。

#### 11.2 剖析 PriorityQueue

本节探讨堆在Java中的具体实现类：PriorityQueue。   
顾名思义，PriorityQueue是优先级队列，它首先实现了队列接口（Queue），与LinkedList类似，
它的队列长度也没有限制，与一般队列的区别是，它有优先级的概念，每个元素都有优先级，
队头的元素永远都是优先级最高的。

PriorityQueue内部是用堆实现的，内部元素不是完全有序的，不过，逐个出队会得到有序的输出。

##### 11.2.1 基本用法

查看代码demo。

##### 11.2.2 实现原理

内部组成

构造方法

添加元素

查看头部元素

删除头部元素（出队）

##### 11.2.3 小结

本节介绍了Java中堆的实现类PriorityQueue，它实现了队列接口Queue，但按优先级出队，
内部是用堆实现的，有如下特点：   
1）实现了优先级队列，最先出队的总是优先级最高的，即排序中的第一个。   
2）优先级可以有相同的，内部元素不是完全有序的，如果遍历输出，除了第一个，其他没有特定顺序。   
3）查看头部元素的效率很高，为O(1)，入队、出队效率比较高，为O(log2(N))，
构建堆heapify的效率为O(N)。   
4）根据值查找和删除元素的效率比较低，为O(N)。

#### 11.3 堆和 PriorityQueue 的应用

1）求前K个最大的元素，元素个数不确定，数据量可能很大，甚至源源不断到来，
但需要知道到目前为止的最大的前K个元素。
这个问题的变体有：求前K个最小的元素，求第K个最大的元素，求第K个最小的元素。

2）求中值元素，中值不是平均值，而是排序后中间那个元素的值，同样，数据量可能很大，
甚至源源不断到来。

##### 11.3.1 求前 K 个最大的元素

解决方法是使用最小堆维护这K个元素，最小堆中，根即第一个元素永远都是最小的，
新来的元素与根比就可以了，如果小于根，则堆不需要变化，否则用新元素替换根，
然后向下调整堆即可，调整的效率为O(log2(K))，这样，总体的效率就是O(N×log2(K))，
这个效率非常高，而且存储成本也很低。使用最小堆之后，第K个最大的元素也很容易获得，
它就是堆的根。

##### 11.3.2 求中值

中值就是排序后中间那个元素的值，如果元素个数为奇数，中值是没有歧义的，但如果是偶数，
中值可能有不同的定义，可以为偏小的那个，也可以是偏大的那个，或者两者的平均值，
或者任意一个，这里，我们假定任意一个都可以。

一个简单的思路是排序，排序后取中间那个值就可以了，排序可以使用Arrays.sort()方法，
效率为O(N× log2(N))。

不过，这要求所有元素都是已知的，而不是动态添加的。如果元素源源不断到来，
如何实时得到当前已经输入的元素序列的中位数？

可以使用两个堆，一个最大堆，一个最小堆，思路如下。

1）假设当前的中位数为m，最大堆维护的是<=m的元素，最小堆维护的是>=m的元素，但两个堆都不包含m。   
2）当新的元素到达时，比如为e，将e与m进行比较，若e<=m，则将其加入最大堆中，
否则将其加入最小堆中。   
3）第2步后，如果此时最小堆和最大堆的元素个数的差值>=2 ，则将m加入元素个数少的堆中，
然后从元素个数多的堆将根节点移除并赋值给m。

代码实现 ChapterEleven.Median。